class NavigatorNode {
	constructor(x, y, wg, wh, idx) {
		this.idx = idx;  
		this.x = x;
		this.y = y;
		this.g = 0;
		this.wg = wg;
		this.wh = wh;
		this.h = 0;
		this.parent = false;
		this.isOpen = false;
		this.isClosed = false;		
		this.inPath = false;
	}
	open() {
		this.isOpen = true;
		this.isClosed = false;
	}
	close() {
		this.isOpen = false;
		this.isClosed = true;
	}
	get F() {
		return Math.round((this.g*this.wg)+(this.h*this.wh));	
	}
	distanceTo(dest) {
		let x = Math.abs(this.x - dest.x);
		let y = Math.abs(this.y - dest.y);
		let d = Math.sqrt((x*x)+(y*y));
		return d;
	}
}
class Navigator {
	constructor(width, height) {
		this.width = width;
		this.height = height;
		this.nodes = [];
		this.nodesPosition = [];
		this.start = { x: 0, y: 0 };
		this.destination = { x: 9, y: 9 };
		this.wg = 1;
		this.wh = 30;
	}
	findPath(maxLoops) {
		this.maxLoops = maxLoops;
		this.loopCount = 0;
		let path = [];
		let startNode = this.nodesPosition[this.start.y][this.start.x];
		let destNode = this.nodesPosition[this.destination.y][this.destination.x];
		startNode.open();
		startNode.h = startNode.distanceTo(destNode);
		startNode.g = 0;
		let currentNode = startNode;
		do {
			let neighbours = this.neighboursOf(currentNode);
			neighbours.forEach((neighbour)=>{				
				if(neighbour.isOpen) {

				} else {
					neighbour.open();
					neighbour.parent = currentNode;
					neighbour.h = neighbour.distanceTo(destNode);
					neighbour.g = currentNode.g + neighbour.distanceTo(currentNode)*10; // ????????? wg
				}				
			});
			currentNode.close();
			currentNode = this.lowestFOpenNode();
			if(currentNode == destNode) {
				console.log("FOUND PATH");
				while(currentNode.parent) {
					path.push(currentNode);
					currentNode.inPath = true;
					currentNode = currentNode.parent;
				}
				path.push(currentNode);
				currentNode.inPath = true;				
				return path;
			}
			this.loopCount += 1;			
		} while (currentNode && this.loopCount < this.maxLoops);
		return path;
	}
	lowestFOpenNode() {
		let lowestFNode = false;
		this.nodes.forEach((node)=>{
			if(node.isOpen) {
				if(!lowestFNode || node.F < lowestFNode.F) {
					lowestFNode = node;
				}
			}
		});
		return(lowestFNode);
	}
	loadMap(map) {
		this.nodes = [];
		this.nodesPosition = [];
		for(let y = 0; y < this.height; y++) {
			this.nodesPosition[y] = [];
			for(let x = 0; x < this.width; x++) {
				if(map[y][x]) {
					this.nodes.push(new NavigatorNode(x, y, this.wg, this.wh, this.nodes.length));
					this.nodesPosition[y][x] = this.nodes[this.nodes.length-1];
				} else {
					this.nodesPosition[y][x] = false;
				}
			}
		}
		return true;
	}
	
	setStart(x, y) {
	
	}
	
	setDestination(x, y) {
	
	}
	neighboursOf(node) {
		let neighbours = [];
		let neighbour = false;
		for(let x = -1; x <= 1; x++) {
			for(let y = -1; y <= 1; y++) {
				neighbour = {x: node.x+x, y: node.y+y};
				if(neighbour.x >=0 && neighbour.y >=0 && neighbour.x < this.width && neighbour.y < this.height) {
					if(!(x==0 && y==0)) {
						if(this.nodesPosition[neighbour.y][neighbour.x]) {
							if(!this.nodesPosition[neighbour.y][neighbour.x].isClosed) {
								neighbours.push(this.nodesPosition[neighbour.y][neighbour.x]);
							}
						}
					}
				}
			}
		}
		return neighbours;
	}	
}